\section{Introduction}
\label{sec:intro}

Over the last decade, microcontrollers, the workhorses of embedded systems, have found
new uses in making~\cite{dougherty2012maker} and education. For example, the Arduino project
(\url{www.arduino.cc})~\cite{buildingArduino2014},
started in 2003, created the Uno board using an 8-bit Atmel
AVR microcontroller with 2Kb of RAM and 32Kb of Flash. 
The Arduino ecosystem has grown over the past 15 years,
with the support of companies such as Adafruit Industries (\url{www.adafruit.com}), 
who resell Arduino and make their own Arduino-compatible boards. Arduino is supported
by many tutorials, supported by the Arduino IDE and its C/C++ programming model.

Furthermore, demand for microcontrollers is brisk due to their use in the monitoring and controlling
of a wide variety of systems, ranging from wearables, to home automation, to industrial 
automation and smart grids. s\emph{compare CPU to microcontroller - what distinguishes MCU from CPU - 
compute to memory ratio - MCU has simple pipeline, very predictable performance - use of concurrency
to structure reactive systems}
Application programming of microcontrollers generally requires a professional
development environment. [TO BE FURTHER EXPANDED BY JOE]

With a surge in the demand for microcontrollers across a wide
spectrum of applications, there is a need to simplify the programming 
of such devices so that more people can participate in the creation 
of microcontroller-based systems. Web-based visual editors such as 
Blockly (\url{https://developers.google.com/blockly/})~\cite{Blocky2015}
are tremendously popular and allow the creation of programs without the 
possibility of syntax errors, and that execute in the web browser (Blockly
is written in JavaScript and compiles user code to JavaScript).
However, JavaScript's dynamic nature is not well-suited to the world of 
microcontrollers where memory is limited (consider the Arduino Uno mentioned above).

We present a platform that bridges the world of the web and the microcontroller with three
novel technologies:
\begin{itemize}
\item \emph{\MCN}, a web app that supports programming, via Blockly and {\em Static TypeScript},
a statically-typed runtime composed of Static TypeScript and C++ (Section~\ref{sec:makecode});

\item \emph{Static TypeScript}, a statically-typed subset of TypeScript 
(\url{www.typescriptlang.org}), for fast execution on low-memory devices, with
a simple model for linking against pre-compiled C++ (Section~\ref{sec:sts});

\item \emph{\CO}, a component-based, event-driven, multi-threaded, C++ runtime environment 
that bridges the semantic gap between higher-level languages (such as TypeScript) and the hardware,
modelling each hardware component as a software component (Section~\ref{sec:codal});

\end{itemize}
The \MC web app is the entry point of the platform, and features
in-browser execution via a device simulator, 
as well as compilation to machine code and linking against a pre-compiled C++ runtime (\emph{\CON}). 
The statically-typed runtime and type inference on user code allows uses to write code
that looks like plain JavaScript (see Figure~\ref{fig:example}) and progress later to working 
with types.
No C/C++ compiler is invoked to compile user code and the result of compilation is a 
binary file that is ``downloaded'' from the web app to the user's
computer and then flashed to the microcontroller (exposed as a USB pen drive)
via a simple file copy operation.

These advances enable beginners to get started programming microcontrollers from
any modern web browser, and enable hardware vendors to innovate and safely add new
components to the mix using Static TypeScript, leveraging its
foreign function interface to C++.
Once the web app has been loaded, all the above functionality works offline
(i.e., if the host machine loses its connection
to the internet). All of the platform's components are open source on GitHub.

\begin{table}[]
\centering
\begin{tabular}{|l|r|r|r|r|r|}
\hline
            &          &            & \bf{Word} &          &             \\
\bf{Device} & \bf{RAM} & \bf{Flash} & \bf{Size} & \bf{CPU} & \bf{Chip}   \\ \hline
Uno         & 2 kB     & 32 kB      & 8         & AVR      & 328P  \\ \hline
micro:bit   & 16 Kb    & 128 KB     & 32        & M0       & nRF51       \\ \hline
CPX         & 32 kB    & 256 kB     & 32        & M0       & SAMD21      \\ \hline
\end{tabular}
\caption{\label{table:devices}A subset of devices supported by the platform.
CPX is Adafruit's Circuit Playground Express. M0 denotes Cortex-M0 and 328P denotes
the Atmega328P.}
\end{table}

Table~\ref{table:devices} lists a number of the devices/microcontrollers supported by our platform, 
ranging from the highly resource-contrained Arduino Uno to the slightly less constrained space of
the micro:bit, and Adafruit Circuit Playground Express (CPX).

\subsection{Running Example: firefly simulation.}

Figure~\ref{fig:example} shows a JavaScript
program that implements a simple ``firefly'' example
for the Adafruit Circuit Playground Express (CPX).
This program demonstrates the natural phenomenon
of fireflies synchronizing their light pulses (the program should be
run on several CPX's close to each other in a dark room).

The program has three top-level statements:
the first initializes the global variable \emph{clock} (line 1); the
second registers an event handler (a lambda function) to execute
each time the CPX's light detector senses a bright light (line 3); the
third registers a lambda function to run forever on a fiber (line 18),
to keep track of time and pulse the CPX's 10 LEDs whenever the
clock reaches 8.  

Note that this program is a JavaScript program, as there are no
types mentioned explicitly. However, all the functions called in
this program are part of the runtime and are explicitly
typed. This program is a Static TypeScript program:
the static type of every variable and expression
can be inferred and passes the more restrictive checks
of Static TypeScript, as detailed in Section~\ref{sec:sts}.

The program also shows off the use of the non-preemptive concurrency
model supported by both \MC (for JavaScript) and \CO (for C++).
The forever procedure executes the lambda inside a ``while (true)''
loop that yields (via a call to \emph{basic.pause}) after each call to the lambda.
This gives the light-detection event handler a chance to execute
upon user input (in a separate fiber). Although the global variable \emph{clock} is
shared by the two fibers, there is no data race due to the non-preemptive
scheduling model.

\begin{figure}
\begin{lstlisting}
  let clock = 0

  input.onLightConditionChanged(
    LightCondition.Bright, () => {
      if (clock < 8) {
          clock += 1    // catchup to neighbor
      }
  })

  loops.forever(() => {
    if (clock >= 8) {
        // notify neighbors
        light.setAll(Colors.White)  
        loops.pause(200)
        light.clear()
        clock = 0         // reset the clock
    } else {
        loops.pause(100)
        clock += 1         
    }
})
\end{lstlisting}
\caption{\label{fig:example}Running example: firefly simulation.}
\end{figure}


\subsection{Evaluation}

%we encourage the reader to choose a target
%from \dburl{www.makecode.com} and experiment with programming it, to appreciate the
%qualitative aspects of the platform, namely its simplicity and ease of use.
In this paper, we evaluate quantitative aspects of the platform
with respect to the devices from Table~\ref{table:devices}. In particular, we
consider:
\begin{itemize}
\item the time to compile Static TypeScript to machine code or bytecode,
       as well as the size of the resulting executable, including the C++ runtime;
\item the performance of a set of small benchmarks, written in both Static TypeScript and C++,
      compiled with the \MC and GCC toolchains;
\item \emph{native code vs. bytecode} we
     evaluate memory consumption and code performance for native code generation
     vs. bytecode generation and interpretation on the Uno.
\end{itemize}
The high-level results are: compilation speed in the browser is on the order
of several hundred milliseconds for small programs (the norm), so not noticeable 
by the end-user; execution slowdown for Static TypeScript code relative to C++
code is 2x-3x, which compares very well to systems such as MicroPython and
Circuit Python, which incur 100X slowdown.

Sections~\ref{sec:makecode} to~\ref{sec:codal} presents the three major components of the platform, top-down,
as referenced before. Section~\ref{sec:evaluate} evaluates the performance of the platform,
Section~\ref{sec:related} discusses related work, and Section~\ref{sec:conclude}
concludes.
