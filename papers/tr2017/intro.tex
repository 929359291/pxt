\section{Introduction}
\label{sec:intro}

Over the last decade, microcontrollers, the workhorses of embedded systems, have found
new uses in making~\cite{dougherty2012maker} and education. For example, the Arduino project
(\url{www.arduino.cc})~\cite{buildingArduino2014},
started in 2003, created the Uno board using an 8-bit Atmel
AVR microcontroller. The Uno makes its microcontroller's I/O pins available via headers;
external hardware modules (shields) may be connected to these headers to extend
the Uno's capability. The Arduino ecosystem has grown over the past 15 years,
with the support of companies such as Adafruit Industries (\url{www.adafruit.com}) and
Sparkfun Electronics (\url{www.sparkfun.com}), who resell Arduino and make their
own Arduino-compatible boards.

Demand for microcontrollers is brisk due to their use in the monitoring and controlling
of a wide variety of systems, ranging from wearables, to home automation, to industrial 
automation and smart grids. s\emph{compare CPU to microcontroller - what distinguishes MCU from CPU - 
compute to memory ratio - MCU has simple pipeline, very predictable performance}
Application programming of microcontrollers generaly requires a professional
development environment. 

% https://globenewswire.com/news-release/2015/12/24/798090/0/en/Microcontroller-Market-Worth-26-98Bn-By-2020-Grand-View-Research-Inc.html
% "The global microcontroller market size was valued at USD 24.61 billion in 2015. The substantial growth in automobile, 
% consumer electronics, and the healthcare sector is expected to attribute to the industry growth.
% The global microcontroller market is expected to reach USD 26.98 billion by 2020,"

% https://www.morganstanley.com/ideas/microcontrollers-semiconductors-internet-of-things
% "Embedded in a product, these tiny chips can efficiently sense, process, 
% and control operations at low cost.  Over the years, chipmakers have been making them 
% smaller, more energy efficient, less expensive, and geared for a mobile and wireless world."

% The Arduino platform has the following characteristics, common to many programming
% environments for microcontrollers~\cite{XYZ}:
% \begin{itemize}
% \item it uses C/C++ as the starting programming language;
% \item it loads code using 1980's era bootloader technology;
% \item it encourages polling of sensors;
% \item it lacks many interactive features of modern IDEs;
% \end{itemize}
% These characteristics make such systems non-trivial for beginners to work with,
% require the installation of OS-specific drivers/applications/toolchains,
% and leads to poor programming practices.

%The Java language (among others) held out the promise of a better way forward for
%programming microcontrollers, but XYZ.
%\flameon{we need more description of why current ways of programming microcontrollers
%make for a high barrier to entry; also need to take on Java head on here, as well as
%RTOS and MicroPython.}

In comparison, on the web we find many environments for introductory programming.
Visual block editors such as Scratch (\url{https://scratch.mit.edu/})~\cite{ScratchCACM2009,BlocksBeyondCACM2017}
and Blockly (\url{https://developers.google.com/blockly/})~\cite{Blocky2015}
allow the creation of programs without the possibility of syntax errors.
The programming models associated with Scratch and Blockly generally are
event based, freeing the programmer from the need to poll.

% HTML, CSS and JavaScript allow a complete programming experience to be delivered as an interactive
% web app, including editing with code completion, code execution and debugging~\cite{Monaco}.

With a surge in the demand for microcontroller-based devices across a wide
spectrum of applications, 
there is a need to simplify the programming of such devices.
Therefore, we have created a new programming platform that bridges the worlds of
the web app and the microcontroller. 

The major goals of the platform are to:
% TypeScript / Blocks + MakeCode
(1) make it simple to program microcontrollers in a higher-level language,
using nothing more than a web app;
% TypeScript and Blocks prevent users from making boo boos.
(2) provide a safe environment for users to develop programs for microcontrollers;
% simulator, auto completion...
(3) create a feature rich and extensible development environment that decreases time taken to program a microcontroller (time to awesome);
% UF2 is awesome
(4) allow a users' compiled program to be easily installed on a microcontroller;


The platform consists of a stack of four novel technologies, the subject of
this paper:
\begin{itemize}
\item \emph{\MCN}, a web app that supports both visual block programming and text programming,
via \emph{Static TypeScript}, with conversion between the two program representations (Section~\ref{sec:makecode});

\item \emph{Static TypeScript}, a statically-typed subset of TypeScript (\url{www.typescriptlang.org}),
a gradually-typed superset of JavaScript, for fast execution on low-memory devices, with
a simple model for linking against pre-compiled C++ (Section~\ref{sec:sts});

\item \emph{\CO}, a component-based, event-driven, multi-threaded, C++ runtime environment that bridges the semantic gap between higher-level languages and the hardware,
modelling each hardware component as a software component (Section~\ref{sec:codal});

\item \emph{\UFN}, a new file format designed for flashing microcontrollers
over the Mass Storage Class protocol (USB pen drives); the format greatly speeds the installation of user
programs and is robust to differences in operating systems (Section~\ref{sec:uf2}).
\end{itemize}
The \MC web app is the entry point of the platform, and has in-browser execution via a device simulator, as well as compilation to machine code and linking against a
pre-compiled C++ runtime (\emph{\CON}). No C/C++ compiler is invoked to compile user code and the result of compilation is a binary file that is ``downloaded'' from the web app to the user's
computer and then flashed to the microcontroller (exposed as a USB pen drive)
via a simple file copy operation,  with the aid of the \emph{UF2} file format and supporting firmware.

These four advances enable beginners to get started programming microcontrollers from
any modern web browser, and enable hardware vendors to innovate and safely add new
components to the mix using Static TypeScript, leveraging its
foreign function interface to C++.
Once the web app has been loaded, all the above functionality works offline
(i.e., if the host machine loses its connection
to the internet). All of the platform's components are open source on GitHub.

\begin{table}[]
\centering
\begin{tabular}{|l|r|r|r|r|r|}
\hline
            &          &            & \bf{Word} &          &             \\
\bf{Device} & \bf{RAM} & \bf{Flash} & \bf{Size} & \bf{CPU} & \bf{Chip}   \\ \hline
Uno         & 2 kB     & 32 kB      & 8         & AVR      & ATmega328P  \\ \hline
micro:bit   & 16 Kb    & 128 KB     & 32        & M0       & nRF51       \\ \hline
CPX         & 32 kB    & 256 kB     & 32        & M0       & SAMD21      \\ \hline
NRF52-DK    & 64 kB    & 256 kB     & 32        & M4-f     & nRF52     \\ \hline
\end{tabular}
\caption{\label{table:devices}A subset of devices supported by the platform.
CPX is Adafruit's Circuit Playground Express. M0 denotes Cortex-M0.}
\end{table}

Table~\ref{table:devices} lists a number of the devices/microcontrollers supported by our platform, 
ranging from the highly resource-contrained Arduino Uno to the slightly less constrained space of
the micro:bit, Adafruit Circuit Playground Express (CPX), and NRF52.

\subsection{Running Example}

Figure~\ref{fig:example} shows a program in the Static
TypeScript subset that implements a simple ``stopwatch'' timer
for the micro:bit.
The program has three top-level statements:
the first initializes the global variable \emph{start} (line 1); the
second registers an event handler (a lambda function) to execute
each time button A of the micro:bit is pressed (line 3); the
third registers a lambda function to run forever on a fiber (line 18),
to animate the micro:bit's 5x5 LED screen whenever the timer is active.

Note that this program is a JavaScript program, as there are no
types mentioned explicitly. However, all the functions called in
this program are part of the runtime and are explicitly
typed.  As a result, the static type of every variable and expression
can be inferred by TypeScript's type inference.

The program also shows off the use of the non-preemptive concurrency
model supported by both \MC (for JavaScript) and \CO (for C++).
The fiber running the forever statement executes the lambda inside a ``while (true)''
loop that yields (via a call to \emph{basic.pause}) after each call to the lambda.
This gives the button-press event handler a chance to execute
upon user input (in a separate fiber). Although the global variable \emph{start} is
shared by the two fibers, there is no data race due to the non-preemptive
scheduling model.

\flameon{TODO: event queueing/execution model???}

\begin{figure}
\begin{lstlisting}
let start = 0

input.onButtonPressed(Button.A, () => {
  if (start == 0) {
    start = input.runningTime()
  } else {
    let d = input.runningTime() - start
    start = 0
    basic.clearScreen()
    basic.pause(1000)
    basic.showString(d/1000 + "." + d%1000)
  }
})

basic.forever(() => {
  if (start) {
    led.toggle(Math.random(5), Math.random(5))
  }
})
\end{lstlisting}
\caption{\label{fig:example}Running example.}
\end{figure}

\subsection{Evaluation}

%we encourage the reader to choose a target
%from \dburl{www.makecode.com} and experiment with programming it, to appreciate the
%qualitative aspects of the platform, namely its simplicity and ease of use.
In this paper, we evaluate quantitative aspects of the platform
with respect to the devices from Table~\ref{table:devices}. In particular, we
consider:
\begin{itemize}
\item the time to compile Static TypeScript user code (to machine code or bytecode),
       as well as the size of the resulting executable;
\item the performance of a set of small benchmarks, written in both Static TypeScript and C++,
      compiled with the \MC and GCC toolchains;
\item the time to load code onto a microcontroller using UF2, compared to standard bootloaders
      such as Arduino and ARM's DAPlink;
%\item \emph{native code vs. bytecode} we
%      evaluate memory consumption and code performance for native code generation
%      vs. bytecode generation and interpretation on the Uno.
\end{itemize}

\flameon{TODO: we should present some of high-level experimental results here.}

Sections~\ref{sec:makecode} to~\ref{sec:uf2} presents the four major components of the platform, top-down,
as referenced before. Section~\ref{sec:evaluate} evaluates the performance of the platform,
Section~\ref{sec:related} discusses related work, and Section~\ref{sec:conclude}
concludes.
