\begin{figure}
    \begin{lstlisting}
    CircuitPlayground cplay;
    SAMD21DMAC dmac;
    Synthesizer synth;
    SAMD21DAC dac(cplay.io.speaker, dmac, synth.output, 44100);
    
    int main()
    {
        // Align sample rate to speaker DAC.
        synth.setSampleRate(dac.getSampleRate());
        synth.setTone(Synthesizer::SawtoothTone);
        synth.setFrequency(300);
    
        while(1) cplay.sleep(100);
    }
    \end{lstlisting}
    \caption{\label{fig:play}Playing a tone using Streams.}
    \end{figure}
    
    \subsection{Streams}
    There are very few scenarios where a processor alone is used to accomplish a task, hence the growth in packaged devices where sensors are distributed alongside a main processing unit. With sensors on boarded, scenarios are centered on the processing, handling, and piping of information generated by sensors.
    
    One scenario is the generation of audio data for a speaker, which has a specific clock rate at which buffers are consumed. Rate pacing the passing of audio buffers to the speaker is challenging --- should it be the users' responsibility to ensure buffers are delivered at the correct time?
    
    In \CON, a stream interface removes the complexity of these scenarios from user applications. Streams are formed of one source node (where data is generated), one sink node (where data is consumed), and 0 or more intermediate data streams which have knowledge of both upstream and downstream interfaces, forming a chain of filters and/or data processing units. Source nodes can push data into the stream, a sink node can pull data down the stream, and a data stream can do either (a Pull/Push model). This means that autonomous tasks can happen in the background, only requiring user intervention if the user application demands it.
    
    The code in Figure~\ref{fig:play} will play a SawtoothTone whilst the device is powered on.