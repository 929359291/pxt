\section{Related Work}
\label{sec:related}

Related work breaks into four parts, following the
flow of the paper: the programming of microcontrollers,
type systems for JavaScript, operating systems
for microcontrollers, and techniques for code loading.

\subsection{Programming microcontrollers}

There are four basic ways to program microcontrollers,
(ordered roughly from lower to greater resource usage):
\begin{itemize}
\item[1.] a program executing on a host computer sends commands (via some communication protocol) 
to a fixed program loaded onto the microcontroller (e.g., Scratch's
device extensions~\cite{ScratchCACM2009}, Arduino's Firmata library~\cite{Firmata}).
\item[2.] a binary for the microcontroller is compiled on a host computer and loaded onto the microcontroller -
this is the common method for Arduino~\cite{buildingArduino2014};
\item[3.] bytecode is compiled on the host and loaded onto microcontroller, where it is interpreted
(e.g., Java for embedded systems~\cite{ClausenTOPLAS}(;
\item[4.] a complete compiler and runtime are put on microcontroller, as with MicroPython~\cite{MicroPython} 
and Espruino~\cite{Espruino};
% 5. an embedded operating system
\end{itemize}

In the educational and maker settings, microcontrollers often are embedded in projects,
option 1 has limited utility. In this case, the microcontroller is powered by battery and
the user program resides in the non-volatile flash memory of the microcontroller. 

For these reasons, our platform supports (2) machine code and (3) byte code generation 
from JavaScript on the host, with reliance on a code loader to place the user's executable 
into flash memory.  The production of the entire executable file
takes places solely within the web app, which is a unique aspect of our platform.
The platform also supports partial flashing of just user code, 
when it can be determined that the proper device runtime already is resident in the microcontroller's flash.

\flameon{need to discuss our design with respect to MicroPython, Espruino (also microJS and JerryScript): 
they would have no chance running on the Uno - microJS doesn't support much of the constructs that we do
- closer to C; big difference is that MakeCode + CODAL supports fibers}

\flameon{Also, we have a concurrency model that needs support both at JavaScript level and C++ runtime}

% https://www.espruino.com/


% https://github.com/jerryscript-project

% JerryScript is a lightweight JavaScript engine for resource-constrained devices
% uch as microcontrollers. It can run on devices with less than 64 KB of RAM and
% less than 200 KB of flash memory.

% Key characteristics of JerryScript:

% Full ECMAScript 5.1 standard compliance
% 160K binary size when compiled for ARM Thumb-2



% https://github.com/cesanta/mongoose-os
% - Supported microcontrollers: CC3220, CC3200, ESP32, ESP8266, STM32F4;
% https://github.com/cesanta/mjs

% On 32-bit ARM mJS engine takes about 25k of flash memory, 
% and less than 1k of RAM (see intro article). mJS is part of MongooseOS,
% where it enables scripting for IoT devices.

% Restrictions
% No closures, only lexical scoping (i.e. nested functions are allowed).
% No new. In order to create an object with a custom prototype, use Object.create(), which is available.
% No getters, setters, classes, template strings.

\subsection{Types for JavaScript}

By design, TypeScript does not provide a soundness guarantee (though see Conjecture XYZ)~\cite{BiermanAT14}.
Type systems with soundness guarantees for JavaScript have as their
goals: (1) handling arbitrary JavaScript programs; (2) XYZ.
Safe TypeScript~\cite{SafeTypeScript15}: distinguishes dynamic from Any type - dynamic means
one of the known static types, where as Any denotes types coming
from raw JavaScript.
StrongScript~\cite{StrongScriptECOOP15}.

Static TypeScript differs from these efforts by outlawing untyped or optionally typed
code; \emph{it is non-goal to support arbitrary JavaScript programs}.
In this sense, it can be seen to be StrongScript where every variable and 
expression has a concrete (!) type.   As in StrongScript, classes are nominally typed,
which permits a more efficient and traditional property lookup for class instances. 
Static TypeScript goes further by outlawing downcasts (for untagged implementation).

Satish Chandra work on type inference for static compilation of JavaScript~\cite{ChandraOOPSLA2016}

\subsection{Operating systems}

Typically written in C and/or C++, platforms for microcontroller programming all share 
a common design goal: to support developers by providing primitives and programming 
abstractions. Platforms can range from simple C++ classes that control hardware, 
to real-time operating systems (RTOSs) with scheduling and memory management.

The Arduino ecosystem is an example of a simple platform where the developer uses 
high-level APIs to control hardware; there is no scheduler, and memory management 
is discouraged through a heavy emphasis on global variables.  The Arduino programming 
model is based on polling: an Arduino ``sketch'' is a program template that consists 
of a setup procedure, for initialization of data structures, and a loop procedure; 
programmers implement the body of \textit{setup} and \textit{loop}, where they explicitly 
poll the state of the sensors or the microcontroller's pins.

At the other end of the spectrum is mbed OS, which is aimed at developers who are familiar 
with non-preemptive scheduling, memory management, and condition synchronisation; a more 
complex environment. A number of high-level drivers are provided and the programming model 
is determined by the developer, commonly event or interrupt driven.

Although platforms like Arduino and mbed OS are widely used by C/C++ developers, 
higher-level languages opt for virtual machines to execute on microcontrollers 
as neither extreme aligns with the programming models seen in higher level languages: 
mbed OS is pre-emptive, JavaScript is not; Arduino is based on monolithic polling. 

The goals of \CO are to: (1) bridge the semantic gap between 
higher-level languages and the hardware in a memory, energy and instruction 
efficient way; and (2) support a number of platforms with various
resource contraints and capabilities.

Unlike mbed, which is designed to make all devices look programmatically alike,
\CO enables devices with additional on-chip hardware to specialise device drivers 
with APIs that can then be used by the end application developer.

% https://state-machine.com/arduino/ 
% http://tinyos.stanford.edu/tinyos-wiki/index.php/TinyOS_Overview 

% Tethered modes: Kodu for micro:bit, Scratch for micro:bit. The PC is central, the microcontroller is peripheral
% Virtual machines: MicroPython, ev3, littlebits, etc.
% Raspberry Pi: complete operating system

\subsection{Code loading}

One solution would be to rely on emerging standards, like WebUSB and WebBluetooth to transfer a program from the browser 
to the microcontroller. These standards are however still in their infancy, and it may take even longer before they are 
deployed in schools.

DAPLink must solve the following problem: it sees a 512 byte block of data to be written
at a particular block index on the device and must decide if it's part of the file being flashed and, if so, extract
the data and write it to the target microcontroller. Furthermore, when the OS writes a HEX file, DAPLink needs to discard
writes to the FAT or directory table, as well as writes of the meta-data files, and may need to deal with out-of-order writes.

Intel's HEX file format doesn't give us these properties 
- the 512 byte boundary can be in the middle of a line in the HEX file, 
and even if we have an entire line, every line only
contains the last 16 bits of the address where to flash, 
with the upper 16 supplied only when they change.

As a result, DAPLink is quite complex and sometimes needs to be updated when a new OS release changes the way
in which it handles FAT. 
This also is the reason that some MSC bootloaders for various chips only support given operating
systems under specific conditions.


% ARM solution