\section{Related Work}
\label{sec:related}

Related work breaks into four parts: the programming of microcontrollers, 
type systems for JavaScript, operating systems
for microcontrollers, and techniques for code loading.

\subsection{Programming microcontrollers}

There are four basic paradigms for programming microcontrollers:
\begin{itemize}
\item a binary for the microcontroller is compiled on a host computer and loaded onto the microcontroller -
this is the common paradigm for Arduino;
\item bytecode for interpretation on the microcontoller is compiled on host and loaded onto microcontroller - 
this is the common paradigm for Java for embedded systems~cite{XYZ};
\item a complete REPL and compiler are put on microcontroller (MicroPython: \url{http://micropython.org/})
\item a program executing on a host computer sends commands to a fixed program loaded onto the
microcontroller, either over a wired connection (USB serial, for example) or a radio network
(Bluetooth, for example) - this paradigm is used by Scratch~\cite{};
\end{itemize}

\emph{\MC supports both native compilation and bytecode generation.}


Web-based programming

\begin{itemize}
\item While the Arduino IDE recently 
has been ported to the web, it lacks basic features of modern IDEs (such as intellisense) 
and needs a connection to a server to invoke a C/C++ compiler on user code;
\item scratch and scratch extensions (provide tethered mode for microcontrollers)
\item 
\end{itemize}

\subsection{Types for JavaScript}

Type systems with soundness guarantees for JavaScript are numerous. 
Safe TypeScript~\cite{SafeTypeScript15}: distinguishes dynamic from Any type - dynamic means
one of the known static types, where as Any denotes types coming
from raw JavaScript.
StrongScript~\cite{StrongScriptECOOP15}.

Static TypeScript differs from these efforts by outlawing untyped or optionally typed
code.  In this sense, it can be seen to be StrongScript where every variable and 
expression has a concrete (!) type.   As in StrongScript, classes are nominally typed,
which permits a more efficient and traditional property lookup for class instances. 
Static TypeScript goes further by outlawing downcasts (for untagged implementation).

% •	Quite a few others…
% MicroPython

\subsection{Operating systems}

Typically written in C and/or C++, platforms for microcontroller programming all share 
a common design goal: to support developers by providing primitives and programming 
abstractions. Platforms can range from simple C++ classes that control hardware, 
to real-time operating systems (RTOSs) with scheduling and memory management.

The Arduino ecosystem is an example of a simple platform where the developer uses 
high-level APIs to control hardware; there is no scheduler, and memory management 
is discouraged through a heavy emphasis on global variables.  The Arduino programming 
model is based on polling: an Arduino ``sketch'' is a program template that consists 
of a setup procedure, for initialization of data structures, and a loop procedure; 
programmers implement the body of \textit{setup} and \textit{loop}, where they explicitly 
poll the state of the sensors or the microcontroller's pins.

At the other end of the spectrum is mbed OS, which is aimed at developers who are familiar 
with non-preemptive scheduling, memory management, and condition synchronisation; a more 
complex environment. A number of high-level drivers are provided and the programming model 
is determined by the developer, commonly event or interrupt driven.

Although platforms like Arduino and mbed OS are widely used by C/C++ developers, 
higher-level languages opt for virtual machines to execute on microcontrollers 
as neither extreme aligns with the programming models seen in higher level languages: 
mbed OS is pre-emptive, JavaScript is not; Arduino is based on monolithic polling. 

The goals of CODAL are to: (1) bridge the semantic gap between 
higher-level languages and the hardware in a memory, energy and instruction 
efficient way; and (2) support a number of platforms with various
resource contraints and capabilities.

Unlike mbed, which is designed to make all devices look programmatically alike,
CODAL enables devices with additional on-chip hardware to specialise device drivers 
with APIs that can then be used by the end application developer.

% https://state-machine.com/arduino/ 
% http://tinyos.stanford.edu/tinyos-wiki/index.php/TinyOS_Overview 

% Tethered modes: Kodu for micro:bit, Scratch for micro:bit. The PC is central, the microcontroller is peripheral
% Virtual machines: MicroPython, ev3, littlebits, etc.
% Raspberry Pi: complete operating system

\subsection{Code loading}

% ARM solution