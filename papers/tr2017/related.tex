\section{Related Work}
\label{sec:related}

Related work breaks into four parts, following the
flow of the paper: the programming of microcontrollers, 
type systems for JavaScript, operating systems
for microcontrollers, and techniques for code loading.

\subsection{Programming microcontrollers}

There are four basic paradigms for programming microcontrollers:
\begin{itemize}
\item[1.] a binary for the microcontroller is compiled on a host computer and loaded onto the microcontroller -
this is the common paradigm for Arduino~\cite{buildingArduino2014};
\item[2.] bytecode for interpretation on the microcontoller is compiled on the host and loaded onto microcontroller - 
this is the common paradigm for Java for embedded systems~\cite{ClausenTOPLAS};
\item[3.] a complete REPL, compiler and runtime are put on microcontroller, as with MicroPython~\cite{MicroPython} 
and Espruino~\cite{Espruino};
\item[4.] a program executing on a host computer sends commands (via some communication protocol) 
to a fixed program loaded onto the microcontroller - this paradigm is the basis of Scratch's
device extensions~\cite{ScratchCACM2009} and Arduino's Firmata library~\cite{Firmata};
\end{itemize}

In the educational and maker settings, microcontrollers often are embedded in projects where a 
connection to a host computer is not possible. In this case, the microcontroller is powered by battery and
the user program resides in the non-volatile flash memory of the microcontroller. For these
reasons, our platform supports native compilation and byte code generation on the host,
with reliance on a code loader (see below) to place the user program into flash memory. 
The production of the entire executable file
takes places solely within the web app, which is a unique aspect of our platform (we
also support partial flashing of just user code when it can be determined that the 
proper device runtime already is resident in the microcontroller's flash).

\flameon{need to discuss our design with respect to MicroPython and Espruino: they would
have no chance running on the Uno}

\flameon{talk about our use of JavaScript for programming microcontrollers - makes it easier 
to support in-browser simulator}

% https://www.espruino.com/Quick+Start


\subsection{Types for JavaScript}

By design, TypeScript does not provide a soundness guarantee (though see Conjecture XYZ)~\cite{BiermanAT14}.
Type systems with soundness guarantees for JavaScript have as their
goals: (1) handling arbitrary JavaScript programs; (2) XYZ.
Safe TypeScript~\cite{SafeTypeScript15}: distinguishes dynamic from Any type - dynamic means
one of the known static types, where as Any denotes types coming
from raw JavaScript.
StrongScript~\cite{StrongScriptECOOP15}.

Static TypeScript differs from these efforts by outlawing untyped or optionally typed
code; \emph{it is non-goal to support arbitrary JavaScript programs}.
In this sense, it can be seen to be StrongScript where every variable and 
expression has a concrete (!) type.   As in StrongScript, classes are nominally typed,
which permits a more efficient and traditional property lookup for class instances. 
Static TypeScript goes further by outlawing downcasts (for untagged implementation).

\subsection{Operating systems}

Typically written in C and/or C++, platforms for microcontroller programming all share 
a common design goal: to support developers by providing primitives and programming 
abstractions. Platforms can range from simple C++ classes that control hardware, 
to real-time operating systems (RTOSs) with scheduling and memory management.

The Arduino ecosystem is an example of a simple platform where the developer uses 
high-level APIs to control hardware; there is no scheduler, and memory management 
is discouraged through a heavy emphasis on global variables.  The Arduino programming 
model is based on polling: an Arduino ``sketch'' is a program template that consists 
of a setup procedure, for initialization of data structures, and a loop procedure; 
programmers implement the body of \textit{setup} and \textit{loop}, where they explicitly 
poll the state of the sensors or the microcontroller's pins.

At the other end of the spectrum is mbed OS, which is aimed at developers who are familiar 
with non-preemptive scheduling, memory management, and condition synchronisation; a more 
complex environment. A number of high-level drivers are provided and the programming model 
is determined by the developer, commonly event or interrupt driven.

Although platforms like Arduino and mbed OS are widely used by C/C++ developers, 
higher-level languages opt for virtual machines to execute on microcontrollers 
as neither extreme aligns with the programming models seen in higher level languages: 
mbed OS is pre-emptive, JavaScript is not; Arduino is based on monolithic polling. 

The goals of \CO are to: (1) bridge the semantic gap between 
higher-level languages and the hardware in a memory, energy and instruction 
efficient way; and (2) support a number of platforms with various
resource contraints and capabilities.

Unlike mbed, which is designed to make all devices look programmatically alike,
\CO enables devices with additional on-chip hardware to specialise device drivers 
with APIs that can then be used by the end application developer.

% https://state-machine.com/arduino/ 
% http://tinyos.stanford.edu/tinyos-wiki/index.php/TinyOS_Overview 

% Tethered modes: Kodu for micro:bit, Scratch for micro:bit. The PC is central, the microcontroller is peripheral
% Virtual machines: MicroPython, ev3, littlebits, etc.
% Raspberry Pi: complete operating system

\subsection{Code loading}

One solution would be to rely on emerging standards, like WebUSB and WebBluetooth to transfer a program from the browser 
to the microcontroller. These standards are however still in their infancy, and it may take even longer before they are 
deployed in schools.

DAPLink must solve the following problem: it sees a 512 byte block of data to be written
at a particular block index on the device and must decide if it's part of the file being flashed and, if so, extract
the data and write it to the target microcontroller. Furthermore, when the OS writes a HEX file, DAPLink needs to discard
writes to the FAT or directory table, as well as writes of the meta-data files, and may need to deal with out-of-order writes.

Intel's HEX file format doesn't give us these properties 
- the 512 byte boundary can be in the middle of a line in the HEX file, 
and even if we have an entire line, every line only
contains the last 16 bits of the address where to flash, 
with the upper 16 supplied only when they change.

As a result, DAPLink is quite complex and sometimes needs to be updated when a new OS release changes the way
in which it handles FAT. 
This also is the reason that some MSC bootloaders for various chips only support given operating
systems under specific conditions.


% ARM solution