\section{The CODAL Runtime}
\label{sec:codal}

% \emph{TBALL comment: the main focus on CODAL here is the support for event-based programming with concurrrent handlers,
%    providing the bridge between scripting languages such as JavaScript and the world of microcontrollers. }

% \emph{TBALL comment: a second focus, also important, is how CODAL is architected to support multiple boards}

Typically written in C and/or C++, platforms for microcontroller programming all share a common design goal: to support developers by providing primitives and programming abstractions. Platforms can range from simple C++ classes that control hardware, to real-time operating systems (RTOSs) with scheduling and memory management.

The Arduino ecosystem is an example of a simplistic platform where the developer has little knowledge of the underlying hardware, using only high-level APIs; there is no scheduler, and memory management is discouraged through a heavy emphasis on global variables.  The Arduino programming model is based on polling: an Arduino ``sketch'' is a program template that consists of a setup procedure, for initialization of data structures, and a loop procedure; programmers implement the body of \textit{setup} and \textit{loop}, where they explicitly poll the state of the sensors or the microcontroller's pins.

At the other end of the spectrum is mbed OS, which is aimed at developers who are familiar with non-preemptive scheduling, memory management, and condition synchronisation; a more complex environment. A number of high-level drivers are provided and the programming model is determined by the developer, commonly event / interrupt driven.

The component-oriented device abstraction layer (CODAL) presents a happy medium between these two extremes. CODAL provides a set of components that abstract away microcontroller specifics, a non-preemptive scheduler that removes the need for resource locking primitives whilst allowing asynchronous operation, and an eventing subsystem common to all CODAL Components that enables the decoupling of system and user code. A CODAL component represents software or hardware drivers (an I2C device, a GPIO pin, a Message Bus, a Bluetooth device); any component can generate or consume events. CODAL supports both polling and asynchronous (event-driven) programming models, which enables higher level languages to map straight onto native CODAL APIs.

\subsection{Software Architecture}

\subsubsection{Message Bus and Events}
\subsubsection{Memory Management}
\subsubsection{Fiber Scheduler}

\subsection{Platform Architecture}

\subsubsection{The Core}
\subsubsection{The Target}
\subsubsection{Supporting Libraries}

