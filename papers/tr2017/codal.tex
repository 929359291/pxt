\section{The CODAL Runtime}
\label{sec:codal}

% \emph{TBALL comment: the main focus on CODAL here is the support for event-based programming with concurrrent handlers,
%    providing the bridge between scripting languages such as JavaScript and the world of microcontrollers. }

% \emph{TBALL comment: a second focus, also important, is how CODAL is architected to support multiple boards}

Typically written in C and/or C++, platforms for microcontroller programming all share a common design goal: to support developers by providing primitives and programming abstractions. Platforms can range from simple C++ classes that control hardware, to real-time operating systems (RTOSs) with scheduling and memory management.

The Arduino ecosystem is an example of a simplistic platform where the developer has little knowledge of the underlying hardware, using only high-level APIs; there is no scheduler, and memory management is discouraged through a heavy emphasis on global variables.  The Arduino programming model is based on polling: an Arduino ``sketch'' is a program template that consists of a setup procedure, for initialization of data structures, and a loop procedure; programmers implement the body of \textit{setup} and \textit{loop}, where they explicitly poll the state of the sensors or the microcontroller's pins.

At the other end of the spectrum is mbed OS, which is aimed at developers who are familiar with non-preemptive scheduling, memory management, and condition synchronisation; a more complex environment. A number of high-level drivers are provided and the programming model is determined by the developer, commonly event or interrupt driven.

Although platforms like Arduino and mbed OS are widely used by C/C++ developers, higher-level languages opt for virtual machines to execute on microcontrollers as neither extreme aligns with the programming models seen in higher level languages: mbed OS is pre-emptive, JavaScript is not; Arduino is too simplistic. There is therefore a need to develop a layer that: (1) bridges the semantic gap between the higher-level language and the hardware; (2) does so in a memory, energy and instruction efficient way; and (3) supports a number of platforms with various resource contraints and capabilities.

% Goals, aims, ambitions:

% want to support multiple platforms, bare metal, unrestricted, async sync, power efficient, flash and memory efficient, good experience for native C and higher level languages.

\subsection{Codal}

The component-oriented device abstraction layer (CODAL) provides a set of components that abstract away microcontroller specifics, a non-preemptive scheduler that removes the need for resource locking primitives whilst allowing asynchronous operation, and an eventing subsystem common to all CODAL Components that enables the decoupling of system and user code. A CODAL component represents software or hardware drivers (an I2C device, a GPIO pin, a Message Bus, a Bluetooth device); any component can generate or consume events. CODAL supports both polling and asynchronous (event-driven) programming models, which enables higher level languages to map straight onto native C/C++ APIs.

Doesn't try to take everything down to the lowest common denominator like mbed... enables customisation for each component. e.g. Pin, extends and implements additional cool functionality.

\subsubsection{Structural Overview}

* support multiple platforms and targets.
* maintain a consistent core
* provide mechanisms for the addition of supporting libraries
* simple builds

\subsubsection{Message Bus and Events}

* Decouples user and system code.
* The scratch model translated to C++
* Provides a similar mechanism seen in higher level languages

\subsubsection{Memory Management}

* provides an interrupt safe environment for memory allocation
* flexible implementation
    - multiple heaps
    - reconfigurable, repurposeable

\subsubsection{Fiber Scheduler}

* ram efficient
* per thread stack size, stack dupe
* fibers can block and wait on events

\subsubsection{Drivers}

* one component per piece of hardware or software
* Provides a common interface
* uses events to decouple from interrupt context.

\subsubsection{Streams}

* Pull and Push model
* Adopted by all stream capable interfaces, from Serial to I2C
* Worked example?

\subsubsection{A code sample}

* That says this is awesome!

\subsubsection{Organisation}

Worked example of how everything fits together, short, only a few sentences.

* the core
* the targets
* supporting library


\subsection{Evaluation}

* Comparison between Codal and other platforms will not work due to the uniqueness of the solution that codal provides. We could compare it to similar (ish) things, but there isn't really a similar thing

* Metrics to evaluate codal on:

    - Profile fibers, how much do they actually use? are they any better?
    - Compare memory allocator to lib c?
    - the measure of how much it glue it takes for TypeScript to use codal?
    - benefits of componentisation?
        - reusability, extensibility
    - How well does codal perform on each device? (SAMD, ATMEGA, NRF52)
        - cost benefit analysis of each.
        - memory (flash and RAM) consumption
        - CPU cycles
            - context switch
            - cost of events
            - code gen, compare against micropython / espruino
        - energy efficiency
            - environmental sensing across 3 different platforms, mbed, espruino, codal
        - how much code does MakeCode add? How efficient is it?


